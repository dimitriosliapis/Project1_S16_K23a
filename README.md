# Project_S16_K23a

### Δομές

* __Buffer__
    Η δομή αποθήκευσης της λίστας γειτνίασης του κάθε κόμβου στο γράφο. Είναι πίνακας από `ListNodes` του οποίου το αρχικό μέγεθος δηλώνεται στο αρχείο `buffer.h` ως `BUFF_SIZE`, και διπλασιάζεται δυναμικά όταν και όσες φορές κριθεί απαραίτητο.

    * `list_node_t`
    Ο τύπος των κόμβων της λίστας γειτνίασης. Αποτελείται από έναν πίνακα `neighbor[N]`, όπου αποθηκεύονται οι γείτονες, έναν πίνακα `edgeProperty[N]`, όπου αποθηκεύεται η έκδοση κάθε ακμής, και ένα offset `nextListNode` του επόμενου ListNode, όπου εάν έχει γεμίσει η λίστα του αρχικού, τότε το χρησιμοποιεί για να αποθηκεύσει τους υπόλοιπους γείτονες, κ.ο.κ.

    * `createBuffer()`  _(Δημιουργία και αρχικοποίηση Buffer)_
    Η αρχική τιμή που δίνεται στα ID (`neighbor[i]`) των γειτόνων είναι η `DEFAULT` η οποία είναι ίση με `2^24`. Η επιλογή αυτή έγινε με βάση την παραδοχή από την εκφώνηση πως η μεγαλύτερη τιμή που μπορεί να πάρει ένα ID είναι η `2^24 - 1`. Ο δείκτης `nextListNode` αρχικοποιείται σε -1. Επιστρέφεται ο δείκτης στο Buffer.

    * `allocNewNode()`  _(Εύρεση offset επόμενης κενής θέσης στο Buffer)_
    Η λειτουργία της συγκεκριμένης συνάρτησης είναι να ελέγχει εάν χωράει στο Buffer ο επόμενος κόμβος. Αν χωράει επιστρέφει το offset, αλλιώς καλεί την συνάρτηση που αυξάνει το μέγεθός του.

    * `reallocBuffer()` _(Διπλασιασμός μεγέθους Buffer)_
    Δέχεται το μέγεθος του Buffer το οποίο διπλασιάζει, αλλάζει την τιμή του μεγέθους του και τέλος αρχικοποιεί τις καινούριες θέσης μνήμης.

    * `destroyBuffer()` _(Απελευθέρωση μνήμης Buffer)_

* __Index__
    Η δομή του ευρετηρίου που χρησιμοποιείται για την ανάκτηση των γειτόνων από τη δομή του Buffer. Είναι πίνακας από `struct index_t` ή αλλιώς `ind`. Έχει ένα αρχικό μέγεθος `IND_SIZE`, το οποίο δηλώνεται στο αρχείο `index.h` και διπλασιάζεται δυναμικά όταν και όσες φορές κριθεί απαραίτητο.

    * `index_t` _(Το struct των κόμβων του Index)_
    Κρατάει για κάθε έναν το offset του πρώτου `first` και του τελευταίου `last` κόμβου της λίστας γειτνίασής του στο Buffer, έναν πίνακα `visited[THREAD_POOL_SIZE + 1]` για να μαρκάρεται ο κόμβος από τα worker threads, ένα hash table `neighbors` για αποδοτικότερο έλεγχο ύπαρξης κάποιου γείτονα, και έναν μετρητή `num_of_children` που κρατάει τον συνολικό αριθμό των γειτόνων του. Τέλος, κρατάει έναν δείκτη `s_data` σε δομή `static_data_t`.

    * `static_data_t`   _(Το struct για την έξτρα πληροφορία σε στατικό γράφο)_
    Κρατάει τα `lowlink`, `index`, `curr_neighbors`, `n`, και `onStack` για τον αλγόριθμο _Tarjan_, και τα `rank`, `min_rank`, `all_children_in_scc[NUM_GRAIL]` και `children_in_scc` για την δημιουργία του _Ευρετηρίου Grail_.

    * `createNodeIndex()`   _(Δημιουργία και αρχικοποίηση Index)_
    Η δημιουργία και οι αρχικοποιήσεις εξαρτόνται από το αν ο γράφος είναι στατικός ή δυναμικός

    * `lookup()`    _(Ύπαρξη ή μη κόμβου στο Index)_
    Επιστρέφει αν υπάρχει ή όχι ο κόμβος με `id` στο Ευρετήριο. Αν το `id` είναι μεγαλύτερο από το μέγεθος του Ευρετηρίου τότε προφανώς ο κόμβος αυτός δεν υπάρχει.

    * `insertNode()`    _(Εισαγωγή κόμβου στο Index)_
    Βρίσκει τον πρώτο ελεύθερο κόμβο στο Buffer μέσω της `allocNewNode()` και μετά εισάγει στη θέση του πίνακα του Ευρετηρίου με αριθμό `id` την τιμή του offset του επόμενου ελέυθερου κόμβου στο Buffer. Αν χρειαστεί, αν δηλαδή το `id` είναι μεγαλύτερο από το μέγεθος του Ευρετηρίου, αυξάνει το μέγεθος του πίνακα `index`. Αυξάνει επίσης την βοηθητική μεταβλητή `available` η οποία δίνει την δυνατότητα εύρεσης του offset του επόμενου κόμβου που θα εισαχθεί στο Buffer σε χρόνο Ο(1).

    * `reallocNodeIndex()`  _(Αύξηση μεγέθους Index)_
    Διπλασιάζει το μέγεθος του πίνακα τόσες φορές όσες χρειάζεται για να χωρέσει το `id`. Αφού γίνει αυτό αρχικοποιεί τις καινούριες θέσεις του πίνακα και αποθηκεύει το νέο μέγεθος.

    * `addEdge()`   _(Προσθήκη ακμής γείτονα)_
    Αρχικά βρίσκει το offset του πρώτου κόμβου της λίστας γειτνίασης στο Buffer για το δοθέν `id`. Αν το όριθμα `check` είναι ίσο με 1, τότε θα ελέγξει με τη βοήθεια του hash table `neighbors` αν η ακμή υπάρχει ήδη. Αλλιώς το id του γείτονα (`neighbor`) εισάγεται στην πρώτη διαθέσιμη θέση στον πίνακα γειτόνων του Buffer.

    * `getListHead()`   _(Εύρεση offset πρώτου κόμβου της λίστας γειτνίασης)_

    * `destroyNodeIndex()`  _(Απελευθέρωση μνήμης Index)_

* __Hash Table__
    Η δομή που χρησιμοποιείται για τον αποδοτικότερο έλεγχο ύπαρξης γείτονα. Το αρχικό του μέγεθος δηλώνεται στο αρχείο `hash.h` ως `HT_SMALL`, ενώ το μέγεθος κάθε bucket ως `HT_N`, και διπλασιάζεται δυναμικά όταν και όσες φορές κριθεί απαραίτητο.

    * `createHashtable()`   _(Δημιουργία hash table)_

    * `search()`    _(Ύπαρξη ή μη κόμβου στο hash table)_

    * `insert()`    _(Εισαγωγή κόμβου στο hash table)_

    * `delete()`    _(Απελευθέρωση μνήμης του hash table)_
    
* __Stack__
    Η δομή που χρησιμοποιείται για την υλοποίηση στοίβας, που βοηθάει στη δημιουργία των SCC, καθώς και στην αποφυγή αναδρομής α) κατά την δημιουργία των CC και β) κατά την αναζήτηση στο UpdateIndex. Το αρχικό της μέγεθος δηλώνεται στο αρχείο `cc.h` ως `STACK_ARRAY_SIZE`, και διπλασιάζεται δυναμικά όταν και όσες φορές κριθεί απαραίτητο.

    * `Stack_t` _(Το struct της στοίβας)_

    * `createStack()`   _(Δημιουργία στοίβας)_

    * `stackisempty()`  _(Έλεχγος για το αν η στοίβα είναι άδεια)_

    * `pushinstack()`   _(Εισαγωγή στοιχείου στην στοίβα)_

    * `popfromstack()`  _(Εξαγωγή στοιχείου από την στοίβα)_
    
    * `peekfromstack()` _(Επιστροφή του τελυταίου στοιχείου που εισήχθει στη στοίβα χωρίς εξαγωγή)_
    
    * `deletestack()`   _(Απελευθέρωση μνήμης της στοίβας)_
    
* __Queue__
    Η δομή που χρησιμοποιείται για την υλοποίηση κυκλικής ουράς, που αναπαριστά το σύνορο στον BFS. Το αρχικό της μέγεθος δηλώνεται στο αρχείο `search.h` ως `QUEUE_SIZE`, και διπλασιάζεται δυναμικά όταν και όσες φορές κριθεί απαραίτητο.
    
    * `queue_t` _(Το struct της ουράς)_
    
    * `createQueue()`   _(Δημιουργία ουράς FIFO με δείκτες στο πρώτο και στο τελευταίο στοιχείο)_
    
    * `isEmpty()`   _(Έλεγχος για το αν η ουρά είναι άδεια)_
    
    * `enq()`   _(Εισαγωγή στοιχείου στο τέλος της ουράς)_
    
    * `deq()`   _(Εξαγωγή του πρώτου στοιχείου της ουράς)_
    
    * `empty()` _(Απελευθέρωση μνήμης για όλα τα στοιχεία της ουράς καθώς και για την ίδια της ουρά)_
    
* __Strongly Connected Components__

    * `Component_t`
        
    * `SCC_t`
    
    * `estimateStronglyConnectedComponents_iterative()`
    
* __Grail Index__

    * `GrailIndex_t`
        
    * `shuffle()`
        
    * `buildGrailIndex()`
    
* __CC Index__
    Δομή που κρατάει ένα προς ένα για κάθε κόμβο το Conected Component στο οποίο ανήκει. Κραταέι επίσης και το Update Index.

    * `CC_ind_t`
    
    
    * `u_unode_t`
    Δομή που κρατάει για κάθε CC με ποιά άλλα συνδέεται μετά από προσθήκη ακμών (`cc_array`) και ένα πίνακα με τους καινούριους κόμβους που θα προστεθούν σε αυτό το CC (`new_nodes`).
    
    * `CC_t`
    

    * `createCCIndex()`
    Δημιουργία CCIndex.

    * `initUpdateIndex()`
    Αρχικοποίηση του UpdateIndex.

    * `refreshUpdateIndex()`
    Προσθήκη αλλαγών στο `updateIndex`. Είτε σύνδεση 2 CC που ήδη υπάρχουν, είτε προσθήκη νέων. Αντίστοιχα για τους νέους κόμβους.

    * `searchUpdateIndex()`
    
    
    * `updateCCIndex()`
    
    
    * `destroyCCIndex()`
    

### Αλγόριθμοι

* __Bidirectional Breadth-First-Search__

    * `bBFS()`
    Διεξάγει δύο αναζητήσεις BFS ταυτόχρονα. Μια απο το κόμβο προορισμού και μια απο τον κόμβο προέλευσης. Σε κάθε μία, ο κόμβος εκκίνησης τοποθετείται στο σύνορο, μαρκάρεται (προστίθεται στον `hashTable`)  και στη συνέχεια, μέχρι να αδειάσει κάποιο από τα δύο σύνορα επαναλαμβάνεται η εξής διαδικασία: με την βοήθεια των `counterF`, `counterFS`, `counterB` και `counterBS` εξάγονται από το εκάστοτε σύνορο οι κόμβοι που μπήκαν στο προηγούμενο βάθος. Για κάθε έναν από τους γείτονές τους, ελέγχεται αν έχουν ξαναεπισκεφτεί και αν όχι, τότε μαρκάρονται, ενώ κατόπιν ελέγχονται αν έχουν επισκεφτεί από τον άλλο BFS. Αν συμβαίνει κάτι τέτοιο τότε έχει βρεθεί μονοπάτι, αλλιώς ο γείτονας τοποθετείται στο σύνορο, κ.ο.κ. Σε περίπτωση που αδειάσει κάποιο από τα δύο σύνορα, τότε δεν υπάρχει μονοπάτι.

* __Tarjan__
    
    * `tarjan_iterative()`
    
    * `destroyStronglyConnectedComponents()`
    
* __Grail__
    
    * `isReachableGrailIndex()`
    
    * `destroyGrailIndex()`
